# Introduction to x86's architecture

## Register Set and Data Types

---

While being in protected mode, the x86 architecture has eight 32--bit general purpose registers \(GPRs\): EAX, EBX, ECX, EDX; EDI, ESI, EBP and ESP. Some of them can be further divided into 8- and 16-bit registers. The instruction pointer is stored in the EIP register.

**Figure 1-1**

<img src="res/registers.png" width="500"/>

**Table 1.1:** Some GPRs and Their Usage

| REGISTER | PURPOSE |
| :--- | :--- |
| ECX | Counter in loops |
| ESI | Source in string/memory operations |
| EDI | Destination in string/memory operations |
| EBP | Base frame pointer |
| ESP | Stack pointer |

The common data types are as follows:
* **Bytes** - 8 bits. Examples AL, BL, CL
* **Word** - 16 bits. Examples AX, BX, CX
* **Double word** - 32 bits. Examples EAX, EBX, ECX
* **Quad word** - 64 bits. While x86 does not have 64-bit GPRs, it can combine
two registers, usually EDX:EAX , and treat them as 64-bit values in some scenarios.
For example, the RDTSC instruction writes a 64-bit value to EDX:EAX.

The 32-bit EFLAGS register is used to store the status of arithmetic operations
and other execution states (e.g., trap fl ag). For example, if the previous “add”
operation resulted in a zero, the ZF flag will be set to 1. The flags in EFLAGS are
primarily used to implement conditional branching.
In addition to the GPRs, EIP, and EFLAGS, there are also registers that control
important low-level system mechanisms such as virtual memory, interrupts, and
debugging. For example, CR0 controls whether paging is on or off, CR2 contains
the linear address that caused a page fault, CR3 is the base address of a paging
data structure, and CR4 controls the hardware virtualization settings. DR0 – DR7
are used to set memory breakpoints. We will come back to these registers later
in the "System Mechanism" section.

> **NOTE** **Although there are seven debug rgisters, the system allows only for four memory breakpoints (DR0-DR3). Remaining registers are used for status.**

There are also model-specifi c registers (MSRs). As the name implies, these
registers may vary between different processors by Intel and AMD. Each MSR
is identified by name and a 32-bit number, and read/written to through the
RDMSR/WRMSR instructions. They are accessible only to code running in ring 0 and
typically used to store special counters and implement low-level functionality.
For example, the SYSENTER instruction transfers execution to the address stored
in the IA32_SYSENTER_EIP MSR (0x176), which is usually the operating system’s
system call handler. MSRs are discussed throughout the book as they come up.

For eaxmple if you'd like to read MSR content with 32-bit identifier `msr_id` you'd have to implement the following code:

```C
static inline rdmsr(uint32_t msr_id)
{
    uint64_t msr_value;
    asm volatile ( "rdmsr", : "=A" (msr_value) : "c" (msr_id) );
    return msr_value;
}
```

## Instruction Set

---

The x86 instruction set allows a high level of flexibility in terms of data movement between registers and memory.
The movement can be classified into five general methods:

+ Immediate to register
+ Register to register
+ Immediate to memory
+ Register to memory and vice versa
+ Memory to memory

The first four methodss are supported by all modern architectures, but the last one is specific to x86.
A classical RISC architecture like ARM can *only* read/write data from/to memory with load/store instructions (LDR and STR respectively);
i.e., a simple operation like incrementing a value in memory requires three instructions:

1. Read data from memory to a register (LDR).
2. Add one to the register.
3. Write the register back to memory (STR).

On x86, such an operation would require only on instruction (either INC or ADD) because it can directly access memory.
The MOVS instruction can read and write memory at the same time.

**ARM**
```
01: 1B 68       LDR      R3, [R3]
; read the value at address R3
02: 5A 1C       ADDS     R2, R3, #1
; add 1 to it
03: 1A 60       STR      R2, [R3]
; write updated value back to address R3
```

**x86**
```
01: FF 00       inc     dword ptr [eax]
; directly increment value at address EAX
```

Another important characteristic is that x86 uses variable-length instruction size: the instruction length can range from 1 to 15 bytes.
On ARM, instructions are either 2 or 4 bytes in length.

### Syntax

Depending on the assembler/disassembler, there are two syntax notations for x86 assembly code, Intel and AT&T:

**Intel**
```
mov ecx, AABBCCDDh
mov ecx, [eax]
mov ecx, eax
```

**AT&T**
```
movl $0xAABBCCDD, %ecx
movl (%eax), %ecx
movl %eax, %ecx
```

It is important to note that these are the same instructions but written differently.
There are several differences between Intel and AT&T notation, but the most notable ones are as follows:

+ AT&T prefi xes the register with % , and immediates with $ . Intel does not do this.
+ AT&T adds a prefi x to the instruction to indicate operation width. For example, MOVL (long), MOVB (byte), etc. Intel does not do this.
+ AT&T puts the source operand before the destination. Intel reverses the order.

Disassemblers/assemblers and other reverse-engineering tools (IDA Pro, OllyDbg, MASM, etc.) on Windows typically use Intel notation, whereas those on UNIX frequently follow AT&T notation (GCC).

### Data Movement

Instructions operate on values that come from registers or main memory. 
The most common instruction for moving data is MOV.
The simplest usage is to move a register or immediate to register. For example:

```
01: BE 3F 00 0F 00		mov		esi, 0F003Fh ; set ESI = 0xF003
02: 8B F1         		mov		esi, ecx
; set ESI = ECX
```

The next common usage is to move data to/from memory. Similar to other assembly language conventions, x86 uses square brackets ( [] ) to indicate memory access (The only exception to this is the LEA instruction, which uses [] but does not actually reference memory.). 
Memory access can be specifi ed in several different ways, so we will begin with the simplest case:

```
01: C7 00 01 00 00+ mov dword ptr [eax], 1
; set the memory at address EAX to 1

02: 8B 08 			mov ecx, [eax]
; set ECX to the value at address EAX

03: 89 18 			mov [eax], ebx
; set the memory at address EAX to EBX

04: 89 46 34 		mov [esi+34h], eax
; set the memory address at (ESI+34) to EAX

05: 8B 46 34 		mov eax, [esi+34h]
; set EAX to the value at address (EAX+34)

06: 8B 14 01 		mov edx, [ecx+eax]
; set EDX to the value at address (ECX+EAX)
```

By the way, the discussing the aforementioned LEA instruction could be helpful in understanding the actual difference between accessing a pointer or a value within C-struct.
Suppose we have the follwing example:

```C
struct Point
{
     int xcoord;
     int ycoord;
};
```

Now imagine a statement like:

```C
int i = points[i].ycoord
```
where `points[]` is an array of `Point`. Assuming the base of the array is already in EBX, and variable i is in EAX, and xcoord and ycoord are each 32 bits (so ycoord is at offset 4 bytes in the struct), this statement can be compiled to:

```
mov edx, [ebx + 8*eax + 4]
; right side is effective address
```
which will land y in EDX. The scale factor of 8 is because each Point is 8 bytes in size. Now consider the same expression used with the "address of" operator &:
```
int *p = &points[i].ycoord;
```
In this case, you don't want the value of ycoord, but its address. That's where LEA (load effective address) comes in. Instead of a MOV, the compiler can generate

```
lea esi, [ebx + 8*eax + 4]
```
which will load the address in ESI.

