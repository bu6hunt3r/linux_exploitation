# Introduction to x86's architecture

## Register Set and Data Types

---

While being in protected mode, the x86 architecture has eight 32--bit general purpose registers \(GPRs\): EAX, EBX, ECX, EDX; EDI, ESI, EBP and ESP. Some of them can be further divided into 8- and 16-bit registers. The instruction pointer is stored in the EIP register.

**Figure 1-1**

<img src="res/registers.png" width="500"/>

**Table 1.1:** Some GPRs and Their Usage

| REGISTER | PURPOSE |
| :--- | :--- |
| ECX | Counter in loops |
| ESI | Source in string/memory operations |
| EDI | Destination in string/memory operations |
| EBP | Base frame pointer |
| ESP | Stack pointer |

The common data types are as follows:
* **Bytes** - 8 bits. Examples AL, BL, CL
* **Word** - 16 bits. Examples AX, BX, CX
* **Double word** - 32 bits. Examples EAX, EBX, ECX
* **Quad word** - 64 bits. While x86 does not have 64-bit GPRs, it can combine
two registers, usually EDX:EAX , and treat them as 64-bit values in some scenarios.
For example, the RDTSC instruction writes a 64-bit value to EDX:EAX.

The 32-bit EFLAGS register is used to store the status of arithmetic operations
and other execution states (e.g., trap fl ag). For example, if the previous “add”
operation resulted in a zero, the ZF flag will be set to 1. The flags in EFLAGS are
primarily used to implement conditional branching.
In addition to the GPRs, EIP, and EFLAGS, there are also registers that control
important low-level system mechanisms such as virtual memory, interrupts, and
debugging. For example, CR0 controls whether paging is on or off, CR2 contains
the linear address that caused a page fault, CR3 is the base address of a paging
data structure, and CR4 controls the hardware virtualization settings. DR0 – DR7
are used to set memory breakpoints. We will come back to these registers later
in the "System Mechanism" section.

> **NOTE** **Although there are seven debug rgisters, the system allows only for four memory breakpoints (DR0-DR3). Remaining registers are used for status.**

There are also model-specifi c registers (MSRs). As the name implies, these
registers may vary between different processors by Intel and AMD. Each MSR
is identified by name and a 32-bit number, and read/written to through the
RDMSR/WRMSR instructions. They are accessible only to code running in ring 0 and
typically used to store special counters and implement low-level functionality.
For example, the SYSENTER instruction transfers execution to the address stored
in the IA32_SYSENTER_EIP MSR (0x176), which is usually the operating system’s
system call handler. MSRs are discussed throughout the book as they come up.

For eaxmple if you'd like to read MSR content with 32-bit identifier `msr_id` you'd have to implement the following code:

```C
static inline rdmsr(uint32_t msr_id)
{
    uint64_t msr_value;
    asm volatile ( "rdmsr", : "=A" (msr_value) : "c" (msr_id) );
    return msr_value;
}
```

## Instruction Set

---

The x86 instruction set allows a high level of flexibility in terms of data movement between registers and memory.
The movement can be classified into five general methods:

+ Immediate to register
+ Register to register
+ Immediate to memory
+ Register to memory and vice versa
+ Memory to memory

The first four methodss are supported by all modern architectures, but the last one is specific to x86.
A classical RISC architecture like ARM can *only* read/write data from/to memory with load/store instructions (LDR and STR respectively);
i.e., a simple operation like incrementing a value in memory requires three instructions:

1. Read data from memory to a register (LDR).
2. Add one to the register.
3. Write the register back to memory (STR).

On x86, such an operation would require only on instruction (either INC or ADD) because it can directly access memory.
The MOVS instruction can read and write memory at the same time.

**ARM**
```
01: 1B 68       LDR      R3, [R3]
; read the value at address R3
02: 5A 1C       ADDS     R2, R3, #1
; add 1 to it
03: 1A 60       STR      R2, [R3]
; write updated value back to address R3
```

**x86**
```
01: FF 00       inc     dword ptr [eax]
; directly increment value at address EAX
```

Another important characteristic is that x86 uses variable-length instruction size: the instruction length can range from 1 to 15 bytes.
On ARM, instructions are either 2 or 4 bytes in length.

### Syntax

Depending on the assembler/disassembler, there are two syntax notations for x86 assembly code, Intel and AT&T:

**Intel**
```
mov ecx, AABBCCDDh
mov ecx, [eax]
mov ecx, eax
```

**AT&T**
```
movl $0xAABBCCDD, %ecx
movl (%eax), %ecx
movl %eax, %ecx
```







